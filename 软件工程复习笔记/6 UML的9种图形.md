# 第6章：类图和对象图

## 类图基本概念

类图是描述类、接口及其他们之间关系的图，显示了系统中各个类的静态结构，是一种静态模型。

类图的组成：2类元素，4种关系

<img src="./assets/image-20231207124810584.png" alt="image-20231207124810584" style="zoom:50%;" />

### 类的符号：

<img src="./assets/image-20231207124908958.png" alt="image-20231207124908958" style="zoom:33%;" />

>   名称分栏必须出现，属性分栏和操作分栏可以出现或者不出现。但隐藏某个分栏并不代表分栏不存在。

### 类图与对象图的区别：

<img src="./assets/image-20231207125038843.png" alt="image-20231207125038843" style="zoom:33%;" />

### 三个层次的观点

-   `概念层`：描述应用域中的概念，与实现它们的类有关，但与现实方案与实现语言无关。
-   `说明层`：描述软件的接口，而不是软件的实现。
-   `实现层`：从实现的角度定义类和其实现。

## 类的组成部分

### 属性

UML属性语法：

**可见性  名称【多重性】：类型 = 缺省值 {约束特性}**

-   可见性：Public(+)、Private(-)、Protected(#)

<img src="./assets/image-20231207125810495.png" alt="image-20231207125810495" style="zoom:33%;" />

-   名称：属性的名称，是一个字符串
-   多重性：低值—高值
-   类型：定义属性的种类
-   缺省值：属性的初始值
-   约束特性：描述对属性的约束

### 操作

操作：描述类行为的函数，也被称为方法。

操作的语法：

**可见性  名称（参数表）：返回类型表达式{约束特性}**

-   可见性：“+”：公有，”#“：受保护，”-“：私有
-   名称：操作的名称
-   参数表：语法与属性参数相同，个数任意
-   返回类型表达式：依赖于语言的表述，可选
-   约束特性：用来描述对操作的约束

#### 两类操作：

-   `查询操作`：执行顺序不重要
-   `修改操作`：执行顺序很重要

## 类的关系

### 关联

关联表示类的对象之间的结构关系，在代码中表现为一个类以属性的形式包含对另一个类的对象的引用。

<img src="./assets/image-20231207130725376.png" alt="image-20231207130725376" style="zoom:25%;" />

**表示方法：**

-   用`无向线段`表示，表示双向关系
-   用`有向线段`表示：是一种单向关系

**二元关联：**两个类之间的关联

<img src="./assets/image-20231207130846747.png" alt="image-20231207130846747" style="zoom: 33%;" />

#### 角色

关联的两端的与类之间的接口表示该类在这个关联中的行为，称之为`角色`。每个关联有两端，所以每个关联有两个角色。

将引出角色的类称为`源`，将引入角色的类称为`目标`。

**角色的多元性：**

<img src="./assets/image-20231207131709895.png" alt="image-20231207131709895" style="zoom:50%;" />

<img src="./assets/image-20231207131817955.png" alt="image-20231207131817955" style="zoom:33%;" />

#### 关联的名称

关联的名称表达了关联的内容，一般使用动宾结构短语。名称仅具有语意作用，不转换为代码。但是关联两端的角色会转换为代码。

<img src="./assets/image-20231207131937435.png" alt="image-20231207131937435" style="zoom: 33%;" />

### 泛化

泛化关系（继承关系）定义类和包之间的一般元素和特殊元素之间的分类关系。

<img src="./assets/image-20231207132733128.png" alt="image-20231207132733128" style="zoom:33%;" />

如果一个类A(父类)的属性和操作能被另一个类B(子类)所继承，则类B不仅可以包含A的属性和操作，还可以添加自己独有的属性和操作，这就是泛化。

#### 多态：

在泛化关系中，父类所定义的操作被子类继承后，可以表现出不同的行为。

多态允许在有继承关系的类中定义同名的操作，并在每一个类中有不同的实现。

<img src="./assets/image-20231207133800502.png" alt="image-20231207133800502" style="zoom:50%;" />

### 聚合和组合

#### 聚合

聚合表示类和类之间的“整体——部分”关系，用空心菱形表示。聚合表示一个类拥有另一个类的对象。

<img src="./assets/image-20231207134028828.png" alt="image-20231207134028828" style="zoom:50%;" />

当整体类不存在时，部分类仍可能存在。部分类销毁的时候，整体类也将能够存在。



#### 组合

组合表示聚合的一种特殊情形，用实心菱形表示。一个部分类最多只能够属于一个整体类，当整体类不存在的时候，部分类将同时被销毁。

<img src="./assets/image-20231207134308473.png" alt="image-20231207134308473" style="zoom:50%;" />

#### 聚合和组合的区别：

-   组合：整体端的重数必须是1，部分类的重数是任意的
-   聚合：整体端的重数可以大于1，部分类的重数是任意的

<img src="./assets/image-20231207134915826.png" alt="image-20231207134915826" style="zoom:50%;" />

#### 关联和聚合的区别：

-   关联：涉及的两个类是在同一个层次上的
-   聚合：涉及的两个类处在不平等的层次上，一个表示整体，一个表示部分。

### 依赖

依赖表示一个类以某种形式依赖于其他类。当两个类处于依赖关系中时，其中一个类的改变可能会影响另一个类。比如说一个类将另一个类的对象作为自己的某个参数或者局部变量。

只要一个类用到了另一个类，但是和另一个类的关系不是太明显的时候，就可以把这种关系看成是依赖。

<img src="./assets/image-20231207141512072.png" alt="image-20231207141512072" style="zoom:50%;" />

### 约束规则

将约束条件放在括号{ }中，用自然语言或者其他常见的设计语言来描述。

<img src="./assets/image-20231207141728641.png" alt="image-20231207141728641" style="zoom:50%;" />

## 对象图

对象图是类图的实例，主要用于了解系统在某个特定时刻的具体情况，以发现类图中的错误，进而修正类图。

与类图的区别：

-   对象只有名称和属性两个分栏，没有操作分栏
-   对象的名称要加下划线
-   对象的属性应该具有具体的值

<img src="./assets/image-20231207142208265.png" alt="image-20231207142208265" style="zoom:50%;" />

对象图的组成：



<img src="./assets/image-20231207142231126.png" alt="image-20231207142231126" style="zoom:50%;" />

<img src="./assets/image-20231207142802509.png" alt="image-20231207142802509" style="zoom:50%;" />

### 小结：

<img src="./assets/image-20231207143414112.png" alt="image-20231207143414112" style="zoom:50%;" />



## 建模步骤

<img src="./assets/image-20231207152058477.png" alt="image-20231207152058477" style="zoom:50%;" />

<img src="./assets/image-20231207152106151.png" alt="image-20231207152106151" style="zoom:50%;" />

1.   先抓住主要分析类，然后根据需求文档找到所有的辅助类。
2.   确定那些是属性那些是类，如果有动词作用的就是类，没有动作作用的只能作为属性。
3.   然后定义属性，根据常识和需求，在根据功能和状态，整体和局部
4.   定义操作：从需求中寻找操作，从系统责任角度寻找，从状态转换中找，从流程中找
5.   画出类图
6.   画出类之间的关系

# 第7章：接口、抽象类和各种关联

## 抽象类

抽象类指的是那些不具有任何对象的类，其作用是为其他的类描述他们的公共属性和行为。

表示：

-   用斜体字表示抽象元素的名称
-   用{abstract}约束来表示

<img src="./assets/image-20231207160327928.png" alt="image-20231207160327928" style="zoom:50%;" />

用abstract修饰的方法叫做抽象方法，由adstract修饰的类叫做抽象类

<img src="./assets/image-20231207160548359.png" alt="image-20231207160548359" style="zoom:33%;" />

## 接口

接口是一组没有实现的操作的集合。接口只提供操作的声明，不提供任何相应的功能代码。具体的功能代码由使用该接口的类实现，叫做实现关系。

类和接口不同，一个类可以有其形态的真实实例，但是一个接口必须至少有一个类来实现它。

表示：

<img src="./assets/image-20231207161503325.png" alt="image-20231207161503325" style="zoom:50%;" />

-   接口中只包含普通函数，不包含构造函数
-   接口中只提供方法的格式声明，而不能包含方法的实现
-   接口中的所有函数都是共有的，不需要添加可见性

<img src="./assets/image-20231207162924154.png" alt="image-20231207162924154" style="zoom:33%;" />

<img src="./assets/image-20231207162935207.png" alt="image-20231207162935207" style="zoom:50%;" />

要实现接口，就必须在类名后包括接口，然后提供接口的每一个成员实现。

在接口成员的声明中不用写可见性，在类中相应接口成员实现定义中都用public。

#### 接口的拓展

可以通过继承来对接口进行组合并拓展。

<img src="./assets/image-20231207165645894.png" alt="image-20231207165645894" style="zoom:50%;" />

#### 常量接口

接口一般用来表示一组行为，但也有时候用来表示静态数据，成为常量接口。

#### 标识接口

标识接口是指没有任何方法和属性的接口。



### 抽象类和接口的相同与不同

相同：

-   接口和抽象类都不能实例化
-   都位于继承的顶端，用于被其他实现或继承
-   都包含抽象方法，其子类都必须覆写这些抽象方法。

区别：

-   抽象类中可以有自己的数据成员也可以有抽象的成员方法。接口中的方法只能有静态的不能被修改的数据成员，方法都是抽象的。
-   抽象类表示的是一种继承关系，一个类只能使用一次继承关系，但是一个类却可以实现多个接口。
-   抽象类中的方法可以有默认行为，但接口中的方法不能有默认行为。

<img src="./assets/image-20231209160631110.png" alt="image-20231209160631110" style="zoom:50%;" />

-   行为模型应该尽量选用接口。
-   需要定义子类的行为而且又要为子类提供通用的行为的时候采用抽象类。

## 特殊的关联关系

### 限定关联

<img src="./assets/image-20231210132851931.png" alt="image-20231210132851931" style="zoom:50%;" />

### 关联类

<img src="./assets/image-20231210133047571.png" alt="image-20231210133047571" style="zoom:50%;" />

### 递归关联

<img src="./assets/image-20231210133119607.png" alt="image-20231210133119607" style="zoom:50%;" />

# 第8章：交互图

## 交互图简介

交互图描述对象之间的动态合作关系以及合作过程中的行为次序。通常用来描述一个用例的行为，显示该用例中所涉及的对象及其之间的消息传递情况。

交互模型建模：

-   序列图：主要描述对象之间信息交换时的时间顺序
-   协作图：用来描述系统对象间如何协作共同完成系统功能的要求

## 顺序图

顺序图强调的是消息发送的时间的先后顺序。在考察系统对象的交互的时候，从顺序图开始，然后将顺序图转换为协同图，分析系统在结构方面应该具备的特点。

顺序图组成部分：

-   对象：用对象框（短式）表示，对象名要带<u>下划线</u>，消亡的时候在生存线上用一个❌表示。
-   生存线：对象框下面画的一条垂直虚线
-   激活期：对象生存线上的一个细长方形框，表示该对象的激活时间段。
-   消息：对象之间消息的发送和接受用两个对象生存线之间的消息箭头线表示。

<img src="./assets/image-20231210134418201.png" alt="image-20231210134418201" style="zoom:50%;" />

越靠近上面的消息越先发送。

### 消息的四种控制流

<img src="./assets/image-20231210135242444.png" alt="image-20231210135242444" style="zoom:50%;" />

-   消息可以有名字，写在消息的箭头的直线上。
-   消息有顺序，所以有顺序号。顺序号在消息名字的前面作为前缀，用冒号分割。顺序号分为两种：
    -   单调顺序号：严格按照消息的发送顺序排序
    -   过程顺序号：过程顺序号是嵌入式的。当一个消息启动了另一个消息序列的时候，消息序列内的各消息可以重新开始编号。

### 控制焦点（激活期）

在UML中，由消息引发的动作的执行过程被描述为控制焦点或者激活期。

#### 控制焦点的嵌套

-   另一个控制焦点向右叠放在父控制焦点上
-   子控制焦点中消息发送的顺序号可以用过程顺序号表示

### 建立顺序图

<img src="./assets/image-20231210141431605.png" alt="image-20231210141431605" style="zoom:50%;" />

<img src="./assets/image-20231210145110407.png" alt="image-20231210145110407" style="zoom:50%;" />

## 协作图

协作图是交互图的另一种表现形式，在语义上和交互图是等价的。协作图描述对象之间的连接关系，侧重说明那些对象之间有消息传递。协作图中对象用对象图符表示，箭头表示消息发送的方向，编号表明消息的执行顺序。

协作图的构成

-   对象
-   连接：对象之间的语义联系，用对象之间相连的直线表示
-   在连接上面传递的消息：用带箭头的直线表示

### 连接的通路

-   Field：对象能被另一个对象看见，是由于此对象是另一个对象的一部分。
-   Paremeter：对象能被另一个对象看见，是因为此对象是另一个对象的某个操作的参数。
-   Local：此对象能被另一个对象看见，是因为此对象生存在另一个对象的局部作用域中。
-   Global：此对象能被另一个对象看见，是因为此对象存在于全局作用域中。

<img src="./assets/image-20231210143512487.png" alt="image-20231210143512487" style="zoom:50%;" />

### 协作图中常用的操作图

-   opt：可选操作符，监护条件为真执行操作符的主体，监护条件是方括号括起来的布尔表达式。

<img src="./assets/image-20231210144454189.png" alt="image-20231210144454189" style="zoom:50%;" />

-   alt：操作符的主体倍分割成几个分区，每个分区有一个监护条件，那个为真就执行哪一个，但只能一次执行一个。所有条件都为假就执行一个特殊分区。

<img src="./assets/image-20231210144650045.png" alt="image-20231210144650045" style="zoom:50%;" />

-   loop：循环执行，满足监护条件就循环执行

<img src="./assets/image-20231210144715576.png" alt="image-20231210144715576" style="zoom:50%;" />

-   ref：引用，引用其他交互，比如子活动
-   break：执行循环中断后要执行的内容。

<img src="./assets/image-20231210144930204.png" alt="image-20231210144930204" style="zoom:50%;" />

-   par：并行执行，每一个分区表示一个并行计算，不同的分区有不同的生命线。

<img src="./assets/image-20231210145021117.png" alt="image-20231210145021117" style="zoom:50%;" />

## 通信图

通信图其实就是以前版本的协作图。通信图从空间角度反映对象之间的组织关系。通信图更加着重描述对象在交互中承担的角色，一个对象能扮演多个角色。

<img src="./assets/image-20231210145332301.png" alt="image-20231210145332301" style="zoom:50%;" />

-   主动对象表示为双重边，用左右边为双线的矩形来表示。
-   “主动对象”变成了“与主动对象绑定的角色”，“被动对象”变成“与被动对象绑定的角色”。
-   名称下面没有下划线
-   “临时链”变成“与临时链绑定的连接器”，“链”也和连接器绑定
-   连接器是结构化类元中的或者协作中的两个结构化部件之间的连接。

看了半天，我感觉协作图就是通信图，没啥区别，只是表示的符号可能有一定不同。

### 顺序图和通信图的区别

<img src="./assets/image-20231210150403861.png" alt="image-20231210150403861" style="zoom:50%;" />

![image-20231210150310234](./assets/image-20231210150310234.png)

# 第9章：状态图

## 状态机

事件驱动的动态行为：根据当前事件，以及对以前事件的响应的结果决定对当前事件的响应的软件对象的动态行为。

适合描述这种动态行为的建模手段就是状态机

-   用状态：记录以前的动态行为的结果
-   用变迁：描述软件对象对外来事件的响应以及响应的状态的变化。

### 与交互图的区别

-   交互图强调的是对象之间的相互协作
-   状态机强调对象本身对对象外部发生的事件的响应及伴随的状态的变化。

对于状态机，其描述的对象是广义的，只要对象的动态行为具有事件驱动的特性，就适合用状态机来建模

### 表示方法：

-   状态用圆角矩形表示：

<img src="./assets/image-20231211123438728.png" alt="image-20231211123438728" style="zoom:33%;" />

-   两种特殊的状态：初始状态和终止状态。
    -   用带实心圆的圆环表示的状态称为状态机的终止状态。
-   `变迁`：两个状态之间的关系，表明在指定的时间发生后，在特定的条件下，对象执行指定的动作，并进入另一个状态。
    -   标识为连接两个状态的箭头，从前状态只想变迁后的状态。
-   `激发`：对象发生了沿变迁箭头方向的变化，那么称变迁被激发
-   `触发事件`：和变迁的激发联系在一起的事件。

### 变迁的构成

-   `起始状态`和`目标状态`：都可以不止一个，表示汇合成一个控制流或者分解成多个控制流。
-   `触发事件`：引发对象动作的事件
-   `触发条件`：布尔表达式
-   `变迁动作`：随着变迁的发生被激发的一个元计算

在表示的时候，触发事件、触发条件和变迁动作被表示成一个字符串放在表示变迁的箭头上。叫做变迁的`文字标记`。

格式：`触发事件 [触发条件] /变迁动作`

## 状态图

状态图描述了一个对象或交互过程在其生命周期中对一系列外界激励所呈现出的不同状态及其相应的响应和活动。

<img src="./assets/image-20231211125829222.png" alt="image-20231211125829222" style="zoom:50%;" />

### 状态图的基本组成

状态图符、迁移图符、起始状态、终止状态、条件判定、发出信号、接受信号和并发等等。

<img src="./assets/image-20231211130435036.png" alt="image-20231211130435036" style="zoom:50%;" />

<img src="./assets/image-20231211131420346.png" alt="image-20231211131420346" style="zoom:50%;" />

### 状态的定义

状态表示的是一个对象或交互过程中的一个特定阶段

一个完整的状态包括：

-   状态名：省略的话就是匿名状态
-   状态变量：状态图所描述的类的属性，可以是临时变量
-   活动：该状态要执行的事件和动作
    -   entry事件：指明在进入该状态时的特定动作
    -   exit事件：指明退出该状态的特定动作
    -   do事件：指明在该状态中要执行的动作

<img src="./assets/image-20231211132159620.png" alt="image-20231211132159620" style="zoom:50%;" />

内部变迁不引起状态变化的变迁，不会触发entry和exit事件。

延迟事件：某些事件不能被马上处理，但也不能忽略，必须在下一个状态处理。当一个内部变迁的触发事件时延迟事件的时候，在此变迁的动作的部分用保留动作defer代替。

### 状态的分类和属性

对象的状态属性分为：嵌套状态、顺序状态、历史状态、同步状态、并发状态。

#### 子状态

包含在某一个状态内部的状态

包含子状态的状态称为复合状态，不包含的就是简单状态。

<img src="./assets/image-20231211132944231.png" alt="image-20231211132944231" style="zoom:50%;" />

串行子状态：一个复合状态的子状态机所在的对象在其生存期内的任一时刻只能处于一个子状态。

<img src="./assets/image-20231211133609320.png" alt="image-20231211133609320" style="zoom:50%;" />

##### 动作和活动

简单状态对应一个动作，组合活动中每个被嵌套的状态图对应着组合状态内正在进行的一个活动。

-   动作：一组可执行的语句，有迁移性、原子性和连续性
-   活动：一组可执行的动作，具有有限性和非原子性

##### 状态的并发和同步

一个状态可以有多个并发的子状态复合前一由条件判断、并发分叉和并发连接图符来表示。

并发状态之间需要通信，或者具有一定的时序关系，称为并发中的同步。

<img src="./assets/image-20231211133808395.png" alt="image-20231211133808395" style="zoom:50%;" />

##### 历史状态

历史状态是一个特殊的子状态，其记录了复合状态被转出时的活跃子状态。

在绘制的时候，用一个被圆环包围的字母H表示历史状态。

-   浅层历史状态：只记忆被转出变迁打断时最外层的活跃状态。
-   深层历史状态：记忆最深层的内嵌活跃子状态，用一个被圆环包围的带星号的字母H表示（H*）

历史状态指示器时一个伪状态，可以有几个进入他的状态迁移，但是没有离开它的状态迁移。

<img src="./assets/image-20231211141741960.png" alt="image-20231211141741960" style="zoom:50%;" />

#### 状态迁移

状态迁移触发表示当一个特定的事件发生或某些条件满足的时候，一个源状态下的对象将完成一些特定的动作，称为迁移触发。

描述状态迁移的形式化语法格式：

-   事件[条件]/动作表达式。发送子句
    -   事件：易发生并可能引发某种活动的一件事
    -   [条件]：由方括号围起来的关系或者逻辑表达式
    -   动作表达式：一个触发状态迁移时可执行的过程表达式
    -   发送子句：动作的一个特例，说明调用的事件名（操作）是那个对象的。

##### 转移的类型

-   自转移：源状态和目标状态为同一个状态

<img src="./assets/image-20231211142256682.png" alt="image-20231211142256682" style="zoom:50%;" />

-   自动转移：根据情况，自动触发进入目标状态，在转移上没有事件。

<img src="./assets/image-20231211142404860.png" alt="image-20231211142404860" style="zoom:50%;" />

-   条件转移：通过分支判断所确定的转移

<img src="./assets/image-20231211142431417.png" alt="image-20231211142431417" style="zoom:50%;" />



#### 事件的种类

-   状态内部事件：entry，exit，do和自定义事件
-   消息：信号事件和调用事件
-   时间事件：after事件、defer事件、when事件
    -   after事件：以关键字after（时间表达式）说明，/后面跟有动作，例如：after（5min）/stop
    -   defer：事件名/defer，延迟事件在本状态中不处理，推迟到下一个状态处理。
    -   when事件，比如：when（温度>140） / 暂停

## 建模步骤

-   确定要进行系统控制的对象，可以从顺序图中寻找
-   确定对象的起始状态和结束状态
-   在对象的生命周期中寻找有意义的控制状态
-   寻找状态之间的转换
-   补充引起转换的条件
-   绘制状态图并补充必要的文档说明

# 第10章：活动图

## 什么是活动图

状态图刻画的都是一些反映型的对象，也就是说对象的动作的执行是由对象外部发生的事件触发的。

但是有的兑现的动态行为并不是由事件驱动的，这类对象就是非反映型对象。当非反映型对象的动态行为被执行的时候，动态行为的一系列动作按照特定的控制逻辑（算法）顺序执行。

>   活动图是一种特殊形式的状态机，用于对计算流程和工作流程建模

-   活动图的状态表示计算过程中所处的各种状态，而不是普通对象的状态。

>   用来为非反映型对象建模的状态机被称为**活动图**

#### 和交互图的比较

-   活动图更看重活动的控制流，描述在对象之间传递的操作
-   交互图着重表现对象到对象的控制流，描述在对象之间传递的消息

#### 和程序流程图的比较

-   流程图描述的是处理的过程，有顺序、分支、循环等结构，有严格的顺序和时间关系
-   活动图描述的是对象活动的顺序关系所遵循的规则，着重表现系统行为，而不是处理过程。通常也没有循环控制结构

#### 和状态图的区别

-   状态图强调在外部事件的驱动下，软件对象的控制在不同的状态之间的流动
-   活动图强调在完成变迁引导下，对象的控制在活动之间的流动。状态迁移不需要触发，执行完自动进入下一个活动状态。

<img src="./assets/image-20231211155952272.png" alt="image-20231211155952272" style="zoom:50%;" />

## 活动图的组成

活动图就是一个为非反应型对象的动态行为建模的活动状态机，主要包含三个方面的内容：动作状态，活动状态和无触发变迁

### 动作状态

>   动作时状态机内原子的计算的执行

原子性：

-   动态行为的最小单位
-   不可打断
-   执行时间可以忽略

用上下为平行直边，两侧用圆弧连接的图形框来表示一个动作

<img src="./assets/image-20231211160633434.png" alt="image-20231211160633434" style="zoom:50%;" />

### 活动状态

>   活动是软件对象非原子的计算的执行，可以被分解成一系列动作

在大多数情况下，系统的动态行为可以用一系列的子过程来表达，而不需要细化到每一个原子的计算。

### 无触发变迁

无触发变迁又叫完成变迁，表示的是不包含触发事件的变迁。

-   如果起始状态是一个简单状态，那么变迁在起始状态的入口动作和状态活动执行完毕之后被触发
-   如果起始状态是复合状态，那么变迁在复合状态的内嵌状态机都大道结束状态后被激发。

要注意的是，源状态的出口动作在变迁激发后执行，然后状态机转入变迁的目标状态。

### 分支

表示的是一个触发事件在不同的触发条件下激发的多个变迁。

用一个`菱形`表示，其包括：

-   at least 一个`输入变迁`
-   多个`输出变迁`（输出变迁都是带触发条件的完成变迁）

<img src="./assets/image-20231211162826424.png" alt="image-20231211162826424" style="zoom:50%;" />

### 循环

循环的结束条件用一个`分支`来表示，下图的分支带有两个转入变迁

<img src="./assets/image-20231211162939433.png" alt="image-20231211162939433" style="zoom:50%;" />

带有两个或者多个转入变迁的菱形符号称为`合并`

### 分解和汇合

在状态机图中，并发的控制流用并发子状态来建模，在活动图中，并发用分解和汇合来建模。

-   分解：一个控制流被分解为两个或多个并发执行的控制流
-   汇合：两个或多个控制流的同步
    -   只有当所有的控制流都到达汇合点之后，控制才继续向下流动

##### 同步条

同步条是一个粗的水平线。

点那个同步条表示分解的时候，可以有一个转入变迁，两个或多个转出变迁。

当同步条用来表示汇合时，可以有两个或多个转入变迁，一个转出变迁。其中的转入变迁代表同步之前的多个并发控制流。

<img src="./assets/image-20231211222407818.png" alt="image-20231211222407818" style="zoom:50%;" />

### 泳道

在语义上的相互关联的活动状态的子集的划分是用泳道来实现的。

-   泳道是活动图里对其中的活动按照其职责上的关联进行的划分。泳道在活动图中是一系列的垂直的隔断。
-   每个活动都属于且只属于一个泳道
-   泳道之间可以有变迁的传递
-   泳道可以有名字

<img src="./assets/image-20231211222832262.png" alt="image-20231211222832262" style="zoom:50%;" />

### 对象流

对象流用虚箭头表示。用对象流表示对象在不同活动之间的流动，

-   活动可以输入对象也可以输出对象。

<img src="./assets/image-20231211223257249.png" alt="image-20231211223257249" style="zoom:50%;" />

### 活动分解

可以用子图展示工作流的细节，然后将子图放在单独的图上，然后将活动状态指向描述细节的子图。

<img src="./assets/image-20231211223538411.png" alt="image-20231211223538411" style="zoom:50%;" />



## 活动图的作用

活动图主要描述控制在活动之间的流动，是一种流程图，所以其主要有两种用途

-   为业务流程建模
    -   用泳道表示不同的业务部门，用活动表示不同的业务步骤
    -   根据泳道的划分，确立相应的协同
    -   利用交互和交互图对软件的动态行为
-   为对象的特定操作建模
    -   对操作的动态行为进行说明、可视化、建档、建造。
    -   活动图可以看作交互图的细化，用交互图定义对象之间的配合，活动图定义这些配合的实现。

## 活动图建模的步骤

<img src="./assets/image-20231211225504355.png" alt="image-20231211225504355" style="zoom:50%;" />

<img src="./assets/image-20231211225558009.png" alt="image-20231211225558009" style="zoom:50%;" />

# 第11章： 组件图

之前讲的类、对象、接口、类图、交互图、用例图、状态图、活动图等描述的都是概念空间之间的事物，适用于逻辑视图。

但是我们必须将概念空间中的软件事物转换为对应物理空间的真实存在，这些真实存在就是用组件来表示的。组件图也用来构建实现视图。

组件的特性

-   存在于物理世界中：形式：计算机文件
-   实现给定的动态行为
-   建造时刻：源代码文件：是设计概念的实现
-   运行时刻：可执行文件、运行库：实现给定的动态行为，可替代。

## 组件

组件是一个物理的和可替代的组成部分，该组成部分遵循并实现了一组给定的接口。组件属于实现视图。

### 图形表示

<img src="./assets/image-20231212111053845.png" alt="image-20231212111053845" style="zoom:50%;" />

### 组件和类的区别与联系

区别：

-   组件存在于物理空间
-   类存在于概念空间

联系：

-   组件和类都是分类符
-   组件用来实现类的动态行为

### 组织形式和分类

组织形式：

-   用包来组织组件
-   用组件之间的交互关系来组织

分类

-   源代码组件
-   二进制组件
-   可执行组件

### 组件和接口

组件化可以替换，让边界更加清晰，便于维护和升级。组件化的系统可以分布式。

组件和接口之间的联系：

-   实现关系：一个组件实现了一个接口，输出接口。被一个组件实现的接口是该组件的实现接口
-   依赖关系：一个组件使用了另一个组件实现的接口所提供的服务。是输入接口

<img src="./assets/image-20231212112327403.png" alt="image-20231212112327403" style="zoom:50%;" />

### 组件的变体

标准变体：

-   可执行文件
-   库文件
-   数据表
-   文件
-   文档

Rose中的组件变体

-   组件

<img src="./assets/image-20231212113441921.png" alt="image-20231212113441921" style="zoom:50%;" />

-   程序规范：一组子程序集合名

<img src="./assets/image-20231212113451690.png" alt="image-20231212113451690" style="zoom:50%;" />

-   子程序体

<img src="./assets/image-20231212113519314.png" alt="image-20231212113519314" style="zoom:50%;" />

-   主程序

<img src="./assets/image-20231212113539956.png" alt="image-20231212113539956" style="zoom:50%;" />

-   包规范：类的头文件，包含类中函数的原型信息

<img src="./assets/image-20231212113555256.png" alt="image-20231212113555256" style="zoom:50%;" />

-   包体：包含类操作代码（.cpp）

<img src="./assets/image-20231212113605654.png" alt="image-20231212113605654" style="zoom:50%;" />

-   任务规范：具有独立控制线程的包

<img src="./assets/image-20231212113659424.png" alt="image-20231212113659424" style="zoom:50%;" />

-   任务体：

<img src="./assets/image-20231212113716576.png" alt="image-20231212113716576" style="zoom:50%;" />

-   数据库

<img src="./assets/image-20231212113751231.png" alt="image-20231212113751231" style="zoom:50%;" />

-   虚包

<img src="./assets/image-20231212113805241.png" alt="image-20231212113805241" style="zoom:50%;" />

-   虚子程序

<img src="./assets/image-20231212113826072.png" alt="image-20231212113826072" style="zoom:50%;" />

## 组件图的作用

-   为可执行文件和库文件建模

<img src="./assets/image-20231212114301832.png" alt="image-20231212114301832" style="zoom:50%;" />

-   为数据表、文件和文档建模

<img src="./assets/image-20231212114626921.png" alt="image-20231212114626921" style="zoom:50%;" />

-   为软件系统建模

    -   为程序API建模

    <img src="./assets/image-20231212115305353.png" alt="image-20231212115305353" style="zoom:50%;" />

    -   为源代码建模

    <img src="./assets/image-20231212115316328.png" alt="image-20231212115316328" style="zoom:50%;" />

## UML2.0 的组件图

<img src="./assets/image-20231212115444111.png" alt="image-20231212115444111" style="zoom:50%;" />

-   为组件的提供接口和要求接口建模

<img src="./assets/image-20231212115638210.png" alt="image-20231212115638210" style="zoom:50%;" />

另一种方式：

<img src="./assets/image-20231212115752402.png" alt="image-20231212115752402" style="zoom:50%;" />

组件内部结构的展示：

<img src="./assets/image-20231212115822290.png" alt="image-20231212115822290" style="zoom:50%;" />

<img src="./assets/image-20231212120202167.png" alt="image-20231212120202167" style="zoom:50%;" />

# 第12章： 部署图

之前讲了什么类图、用例图、状态图等等都是逻辑视图的内容，然后组件图讲的是物理实现，用在实现视图，然后这些物理资源需要部署，就需要用部署图来建模，部署图用于部署视图。

节点：节点表示一个运行时刻的物理对象，代表一类计算资源。

部署视图：用来描述软件产品在计算机硬件系统和网络上的安装、分发和分布。

部署视图的静态特性就用部署图来描述。包含了：

-   节点
-   节点和组件之间的联系
-   节点和节点之间的联系

## 部署图的作用

一个UML部署图描述了一个运行时的硬件结点，以及在这些节点上运行的软件组件的静态视图。

部署图显示了系统的硬件，安装在硬件上的软件以及用于连接异构的机器之间的中间件。

创建一个部署模型能够：

-   探究系统投产的相关问题
-   探究你的系统和生产环境中其他系统的依赖关系
-   描述一个商业应用主要的部署结构
-   设计一个嵌入系统的硬件和软件结构
-   描述一个组织的硬件/网络基础结构



## 部署图的组成

### 节点

节点是一个运行时刻的物理对象，代表一类计算资源，至少具备存储功能，并在大多数情况下具备数据处理的能力

#### 节点的表示

用一个立方体来表示

<img src="./assets/image-20231212145132165.png" alt="image-20231212145132165" style="zoom:50%;" />

分为：

-   处理器：具备计算功能
-   设备：不具备计算功能

<img src="./assets/image-20231212145204687.png" alt="image-20231212145204687" style="zoom:50%;" />

还可以用扩充机制来描述

-   characteristics（特性）
-   processes（进程）
-   scheduling（调度）

<img src="./assets/image-20231212150134681.png" alt="image-20231212150134681" style="zoom:50%;" />

### 节点和组件

共性：

-   都是分类符：都可以有实力，可以为其指定属性和操作
-   都可以通过关系相互连接
-   都可以参与交互

区别：

-   组件用来参与系统的执行，节点执行组件的动态行为
-   组件是逻辑概念的物理包装，节点是组件存在的物理载体

<img src="./assets/image-20231212150401149.png" alt="image-20231212150401149" style="zoom:50%;" />

### 节点之间的连接

节点之间最常见的关系是关联关系。

节点之间的关联关系代表节点之间的物理连接

-   网络连接
-   串口连接
-   共享总线
-   间接连接

<img src="./assets/image-20231212150551499.png" alt="image-20231212150551499" style="zoom:50%;" />

### 节点建模

#### 为节点建模

为处理器和设备建模

为系统的拓扑结构建模

-   分布式系统
-   客户机/服务器系统
-   嵌入式系统

##### 建模一般规则

-   从系统的部署视图中辨别出物理的计算资源，把他们用节点表示
-   用<<processor>>或<<device>>对其进行修饰
-   必要的时候定义其他变体
-   可以考虑为节点指定属性和操作

<img src="./assets/image-20231212151448975.png" alt="image-20231212151448975" style="zoom:50%;" />

#### 为组件的部署建模

用节点来描述软件组件在具有特定拓扑结构的物理连接的各节点之间的分布

##### 建模一般规则

-   将系统中各有意义的组件分配到相应节点
-   考虑同一个组件在多个不同节点上的部署
-   描述组件和节点的联系
    -   在节点的规格说明中描述，不出现在模型图上
    -   使用依赖关系连接组件和节点
    -   在模型图上讲节点包含的组件列在节点的一个单独的分隔区内。

<img src="./assets/image-20231212151740244.png" alt="image-20231212151740244" style="zoom:50%;" />







